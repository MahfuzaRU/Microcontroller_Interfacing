
// Master I2C Communication Protocol

// List of Register Declarations
#define RCC_BASE   (0x40023800)
#define GPIOA_BASE (0x40020000)
#define GPIOB_BASE (0x40020400)
#define I2C1_BASE  (0x40005400)
#define TIM2_BASE  (0x40000000)

#define RCC_AHB1ENR (*(volatile unsigned int *)(RCC_BASE + 0x30))
#define RCC_APB1ENR (*(volatile unsigned int *)(RCC_BASE + 0x40))

#define GPIOA_MODER (*(volatile unsigned int *)(GPIOA_BASE + 0x00))
#define GPIOA_OTYPER (*(volatile unsigned int *)(GPIOA_BASE + 0x04))
#define GPIOA_ODR   (*(volatile unsigned int *)(GPIOA_BASE + 0x14))

#define GPIOB_MODER (*(volatile unsigned int *)(GPIOB_BASE + 0x00))
#define GPIOB_OTYPER (*(volatile unsigned int *)(GPIOB_BASE + 0x04))
#define GPIOB_PUPDR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C))
#define GPIOB_AFRH  (*(volatile unsigned int *)(GPIOB_BASE + 0x24))

#define I2C1_CR1 (*(volatile unsigned int *)(I2C1_BASE + 0x00))
#define I2C1_CR2 (*(volatile unsigned int *)(I2C1_BASE + 0x04))
#define I2C1_CCR (*(volatile unsigned int *)(I2C1_BASE + 0x1C))
#define I2C1_TRISE (*(volatile unsigned int *)(I2C1_BASE + 0x20))
#define I2C1_SR1 (*(volatile unsigned int *)(I2C1_BASE + 0x14))
#define I2C1_SR2 (*(volatile unsigned int *)(I2C1_BASE + 0x18))
#define I2C1_DR  (*(volatile unsigned int *)(I2C1_BASE + 0x10))

#define TIM2_PSC (*(volatile unsigned int *)(TIM2_BASE + 0x28))
#define TIM2_ARR (*(volatile unsigned int *)(TIM2_BASE + 0x2C))
#define TIM2_CR1 (*(volatile unsigned int *)(TIM2_BASE + 0x00))
#define TIM2_SR  (*(volatile unsigned int *)(TIM2_BASE + 0x10))

//function definition to reduce warning
void I2C1_Init();  // 3) STM32_Nucleo_64_boards_Manualcs Page: 1, 35


//send function
void I2C1_Send(char saddr, int n, char* str);


//main function
int main(void) {
	I2C1_Init();
	while(1) {
		I2C1_Send(0x12, 6, "CSE-RU");
	}
}



void I2C1_Init() {

	// 2) STM32f446re_DataSheet - 58
	// 2) STM32f446re_DataSheet - 16
	// 1) STM32f446xx_Reference - 144
	/*Enable clock of GPIOB through AHB1ENR--144*/
	RCC_AHB1ENR |= (1<<1);

	// 2) STM32f446re_DataSheet - 58
	// 1) STM32f446xx_Reference - 187
	/*Set PB8 & PB9 mode to alternate function through GPIOB_MODER , default input mode-- 187*/
	GPIOB_MODER |= (1<<19);  // Set 1
	GPIOB_MODER &= ~(1<<18); // Set 0 or Reset
	GPIOB_MODER |= (1<<17);
	GPIOB_MODER &= ~(1<<16);

	// I2C Open Drain Gif (https://www.linkedin.com/pulse/i2c-how-does-select-push-pull-output-open-drain-nianhang-hu-jdtmc/)
	// 1) STM32f446xx_Reference - 188
	/*Set PB8 & PB9 output type to open-drain for high to low --188*/
	GPIOB_OTYPER |= (1<<8);
	GPIOB_OTYPER |= (1<<9);

	// 1) STM32f446xx_Reference - 189
	/*Set PB8 & PB9 to output pull-up for always high and take internal power -- 189*/
	GPIOB_PUPDR &= ~(1<<19);
	GPIOB_PUPDR |= (1<<18);
	GPIOB_PUPDR &= ~(1<<17);
	GPIOB_PUPDR |= (1<<16);

	// 2) STM32f446re_DataSheet - 58
	// 1) STM32f446xx_Reference - 192
	/*Set PB8 & PB9 alternate function type to I2C (AF4) for handling multiple function -- 192*/
	GPIOB_AFRH &= ~(0xFF<<0);
	GPIOB_AFRH |= (1<<2);
	GPIOB_AFRH |= (1<<6);


	// 2) STM32f446re_DataSheet - 16
	// 1) STM32f446xx_Reference - 147
	/*Enable clock of I2C1 --147*/
	RCC_APB1ENR |= (1<<21);

	// 1) STM32f446xx_Reference - 780
	/*Enter I2C peripheral reset mode -- 780*/
	I2C1_CR1 |= (1<<15);

	// 1) STM32f446xx_Reference - 780
	/*Come out of reset mode --780*/
	I2C1_CR1 &= ~(1<<15);

	// 2) STM32f446re_DataSheet - 16
	// 1) STM32f446xx_Reference - 782, 783
	/*Set I2C clock frequency (default 16 MHz) -- 782*/
	I2C1_CR2 |= (1<<4);

	
	// *** Important Part ***
	// 2) STM32f446re_DataSheet - 16 
	// 1) STM32f446xx_Reference - 790
	/*Set I2C in standard mode, 100 KHz -- 790*/
	//	       CCR = f_PCLK1 / (2 * f_SCL)
	//	    	   = 16,000,000 / (2 * 100,000)
	//	    	   = 80


	I2C1_CCR = 80;

	// 1) STM32f446xx_Reference - 761, 792
	/*Set rise time of Clock Frequency --- 761  & 791*/

	// 		   TRISE = (t_r * f_PCLK1) + 1
	// 		   		 = (1x10^-6 * 16x10^6) + 1
	// 		   		 = 17
	I2C1_TRISE = 17;

	// 1) STM32f446xx_Reference - 780, 782
	/*Now finally enable the I2C1 , Must in Last-- 780*/
	I2C1_CR1 |= (1<<0);

}

// Need address in I2C than UART, Here, saddr - Slave Address (See I2C and UART) 
void I2C1_Send(char saddr, int n, char* str) {
	
	// 1) STM32f446xx_Reference - 761, 789, 790
	/*Wait when bus is busy 789*/
	while(I2C1_SR2 & (1<<1)) {}

	// 1) STM32f446xx_Reference - 780, 785, 788
	/*Generate start condition and wait -- 780 & 785*/
	I2C1_CR1 |= (1<<8);             // Set Start Condition
	while(!(I2C1_SR1 & (1<<0))) {}  // Then Check and Wait is it Set or Not


	// See I2C Message Packet Start->Address
	// 1) STM32f446xx_Reference - 785, 788, I2C Address Frame, 762,785 
	// 1) STM32f446xx_Reference - 785, 788 (ACK as Address Match)
	/*Send slave address + write (0) bit and wait for ACK -- 762 & 785*/
	I2C1_DR = (saddr<<1);  // Set 0 to bit 0 position (master write), automaticall done because of left shift
	while(!(I2C1_SR1 & (1<<1))) {}   // 1st Read SR1

	// 1) STM32f446xx_Reference - 788 
	/*Clear ADDR flag to ensure address is sent -- 788*/
	(void)I2C1_SR2;   // 2nd Read SR2 int temp = I2C1_SR2 will generate warning

	// Start Data Transfer Byte by Byte
	// 1) STM32f446xx_Reference - 762 
	// Check whether Data Register is Empty or Not.
	// 1) STM32f446xx_Reference - 785, 787

	for(int i = 0; i < n; i++) {

		/*Wait until transmitter is empty -- 785*/
		while(!(I2C1_SR1 & (1<<7))) {}

		/*Place the data to the data register one byte at time*/
		I2C1_DR = *str++;
	}

	// 1) STM32f446xx_Reference - 785, 787
	/*Wait until transfer finished --788*/
	while(!(I2C1_SR1 & (1<<2))) {}

	// 1) STM32f446xx_Reference - 780, 781
	/*Generate stop -- 780*/
	I2C1_CR1 |= (1<<9);
}

// Slave I2C Communication Protocol

// List of Register Declarations
#define RCC_BASE 	(0x40023800)
#define GPIOB_BASE  (0x40020400)
#define GPIOA_BASE  (0x40020000)
#define I2C1_BASE 	(0x40005400)
#define TIM2_BASE 	(0x40000000)

#define RCC_AHB1ENR (*(volatile unsigned int *)(RCC_BASE + 0x30))
#define RCC_APB1ENR (*(volatile unsigned int *)(RCC_BASE + 0x40))
#define RCC_CFGR 	(*(volatile unsigned int *)(RCC_BASE + 08))

#define GPIOA_MODER (*(volatile unsigned int *)(GPIOA_BASE + 0x00))
#define GPIOA_OTYPER (*(volatile unsigned int *)(GPIOA_BASE + 0x04))
#define GPIOA_ODR 	(*(volatile unsigned int *)(GPIOA_BASE + 0x14))

#define GPIOB_MODER (*(volatile unsigned int *)(GPIOB_BASE + 0x00))
#define GPIOB_OTYPER (*(volatile unsigned int *)(GPIOB_BASE + 0x04))
#define GPIOB_PUPDR (*(volatile unsigned int *)(GPIOB_BASE + 0x0C))
#define GPIOB_AFRH 	(*(volatile unsigned int *)(GPIOB_BASE + 0x24))

#define I2C1_CR1 	(*(volatile unsigned int *)(I2C1_BASE + 0x00))
#define I2C1_CR2 	(*(volatile unsigned int *)(I2C1_BASE + 0x04))
#define I2C1_CCR 	(*(volatile unsigned int *)(I2C1_BASE + 0x1C))
#define I2C1_TRISE  (*(volatile unsigned int *)(I2C1_BASE + 0x20))
#define I2C1_SR1 	(*(volatile unsigned int *)(I2C1_BASE + 0x14))
#define I2C1_SR2 	(*(volatile unsigned int *)(I2C1_BASE + 0x18))
#define I2C1_DR 	(*(volatile unsigned int *)(I2C1_BASE + 0x10))
#define I2C1_OAR1 	(*(volatile unsigned int *)(I2C1_BASE + 0x08))

#define TIM2_PSC (*(volatile unsigned int *)(TIM2_BASE + 0x28))
#define TIM2_ARR (*(volatile unsigned int *)(TIM2_BASE + 0x2C))
#define TIM2_CNT (*(volatile unsigned int *)(TIM2_BASE + 0x24))
#define TIM2_CR1 (*(volatile unsigned int *)(TIM2_BASE + 0x00))
#define TIM2_SR  (*(volatile unsigned int *)(TIM2_BASE + 0x10))

void I2C1_Init(void);
void I2C1_Read(int n, char *str);

int main(void) {
	I2C1_Init();
	char str[6];
	while(1) {
		I2C1_Read(6, str);
	}
}

void I2C1_Init() {

	/*Enable clock of GPIOB through AHB1ENR*/
	RCC_AHB1ENR |= (1<<1);

	/*Set PB8 & PB9 mode to alternate function thru GPIOB_MODER*/
	GPIOB_MODER |= (1<<19);
	GPIOB_MODER &= ~(1<<18);
	GPIOB_MODER |= (1<<17);
	GPIOB_MODER &= ~(1<<16);

	/*Set PB8 & PB9 output type to open-drain*/
	GPIOB_OTYPER |= (1<<8);
	GPIOB_OTYPER |= (1<<9);

	/*Set PB8 & PB9 to output pull-up*/
	GPIOB_PUPDR &= ~(1<<19);
	GPIOB_PUPDR |= (1<<18);
	GPIOB_PUPDR &= ~(1<<17);
	GPIOB_PUPDR |= (1<<16);

	/*Set PB8 & PB9 alternate function type to I2C (AF4)*/
	GPIOB_AFRH &= ~(0xFF<<0);
	GPIOB_AFRH |= (1<<2);
	GPIOB_AFRH |= (1<<6);

	/*Enable clock of I2C1*/
	RCC_APB1ENR |= (1<<21);

	/*Enter I2C peripheral reset mode*/
	I2C1_CR1 |= (1<<15);

	/*Come out of reset mode*/
	I2C1_CR1 &= ~(1<<15);

	/*Set I2C clock frequency (default 16 MHz)*/
	I2C1_CR2 |= (1<<4);

	/*Set slave address -- 784*/
	I2C1_OAR1 = (0x12<<1);

	/*Enable the address 784*/
	I2C1_OAR1 |= (1<<14);

	/*Now finally enable the I2C1*/
	I2C1_CR1 |= (1<<0);
}

void I2C1_Read(int n, char *str) {
	/*Enable acknowledge for slave -- 780*/
	I2C1_CR1 |= (1<<10);

	/* Wait for address match 785*/
	while (!(I2C1_SR1 & (1 << 1))) {}

	/* Clear ADDR flag */
	(void)I2C1_SR2;

	for (int i = 0; i < n; i++) {

		/* Wait until data is received */
		while (!(I2C1_SR1 & (1 << 6))) {}

		/* Read received data */
		str[i] = I2C1_DR;
	}

	/*Disable acknowledge for slave*/
	I2C1_CR1 &= ~(1<<10);
}

//uart receiver

#define RCC_BASE (0x40023800)
#define GPIOA_BASE (0x40020000)
#define UART1_BASE (0x40011000)

#define RCC_AHB1ENR (*(volatile unsigned int *)(RCC_BASE + 0x30))
#define RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x44))

#define GPIOA_MODER (*(volatile unsigned int *)(GPIOA_BASE + 0x00))
#define GPIOA_AFRH (*(volatile unsigned int *)(GPIOA_BASE + 0x24))

#define UART1_SR (*(volatile unsigned int *)(UART1_BASE + 0x00))
#define UART1_BRR (*(volatile unsigned int *)(UART1_BASE + 0x08))
#define UART1_CR1 (*(volatile unsigned int *)(UART1_BASE + 0x0C))
#define UART1_DR (*(volatile unsigned int *)(UART1_BASE + 0x04))

#define SYSCLK 16000000U
#define BAUDRATE 9600U

void uart1_tx_init(void);
void uart1_receive(int n, char *str);

int main(void) {
	uart1_tx_init();
	char str[6];
	while(1) {
		uart1_receive(6, str);
		(void)str;
	}
}

void uart1_tx_init() {

	/*1) STM32f446xx_Reference Page: 144*/
	/* Enable clock of port A*/
	RCC_AHB1ENR |= (1<<0);

	/*1) STM32f446xx_Reference Page: 187*/
	/*PA10 to alternate function mode 10 at bit 20 and 21*/
	GPIOA_MODER &= ~(3 << 20);  // Clear bits 20:21
	GPIOA_MODER |=  (2 << 20);  // Set to Alternate Function mode (10)

	/*1) STM32f446xx_Reference Page: 192*/
	/*AF7 (0111)*/
	GPIOA_AFRH &= ~(0xF<<8); //clear bit 8-11
	GPIOA_AFRH |= (7<<8);

	/*1) STM32f446xx_Reference Page: 149*/
	/*Clock of USART1*/
	RCC_APB2ENR |= (1<<4);

	/*1) STM32f446xx_Reference Page: 838*/
	/*Configure BaudRate*/
	UART1_BRR = (SYSCLK + (BAUDRATE / 2)) / BAUDRATE;

	/*1) STM32f446xx_Reference Page: 839*/
	/* Enable RE*/
	UART1_CR1 = (1 << 2);

	/*Enable the UART1*/
	UART1_CR1 |= (1<<13);
}

void uart1_receive(int n, char* str) {
	for(int i = 0; i < n; i++) {
		/*1) STM32f446xx_Reference Page: 835*/
		/* Rx data register is empty*/
		while(!(UART1_SR & (1<<5))) {}
		/*1) STM32f446xx_Reference page: 838*/
		str[i] = UART1_DR;
	}
}

//uart transmitter

#define RCC_BASE (0x40023800)
#define GPIOA_BASE (0x40020000)
#define UART1_BASE (0x40011000)

#define RCC_AHB1ENR (*(volatile unsigned int *)(RCC_BASE + 0x30))
#define RCC_APB2ENR (*(volatile unsigned int *)(RCC_BASE + 0x44))

#define GPIOA_MODER (*(volatile unsigned int *)(GPIOA_BASE + 0x00))
#define GPIOA_AFRH (*(volatile unsigned int *)(GPIOA_BASE + 0x24))

#define UART1_SR (*(volatile unsigned int *)(UART1_BASE + 0x00))
#define UART1_BRR (*(volatile unsigned int *)(UART1_BASE + 0x08))
#define UART1_CR1 (*(volatile unsigned int *)(UART1_BASE + 0x0C))
#define UART1_DR (*(volatile unsigned int *)(UART1_BASE + 0x04))

#define SYSCLK 16000000U
#define BAUDRATE 9600U

void uart1_tx_init(void);
void uart1_send(int n, char* str);

int main(void) {
	uart1_tx_init();
	while(1) {
		uart1_send(6, "CSE-RU");
	}
}

void uart1_tx_init() {

	/*1) STM32f446xx_Reference Page: 144*/
	/* Enable clock of port A*/
	RCC_AHB1ENR |= (1<<0);

	/*1) STM32f446xx_Reference Page: 187*/
	/*PA9 to alternate function mode 10 at bit 18 and 19*/
	GPIOA_MODER &= ~(3 << 18);  // Clear bits 18:19
	GPIOA_MODER |= (2 << 18);  // Set to Alternate Function mode (10)

	/*1) STM32f446xx_Reference Page: 192*/
	/*AF7 (0111)*/
	GPIOA_AFRH &= ~(0xF<<4); //clear bit 4-7
	GPIOA_AFRH |= (7<<4);

	/*1) STM32f446xx_Reference Page: 149*/
	/*Clock of USART1*/
	RCC_APB2ENR |= (1<<4);

	/*1) STM32f446xx_Reference Page: 838*/
	/*Configure BaudRate*/
	UART1_BRR = (SYSCLK + (BAUDRATE / 2)) / BAUDRATE;

	/*1) STM32f446xx_Reference Page: 839*/
	/* Enable TE*/
	UART1_CR1 = (1<<3); // Directly assigned, intentionally cleared other bits

	/*Enable the UART1*/
	UART1_CR1 |= (1<<13);
}

void uart1_send(int n, char* str) {
	for(int i = 0; i < n; i++) {

		/*1) STM32f446xx_Reference Page: 835*/
		/* Tx data register is empty*/
		while(!(UART1_SR & (1<<7))) {}

		/*1) STM32f446xx_Reference page: 838*/
		UART1_DR = *str++;
	}
}

